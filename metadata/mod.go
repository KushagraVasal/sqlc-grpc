package metadata

import (
	"bytes"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"path"
	"path/filepath"
	"slices"
	"strings"

	"github.com/walterwanderley/sqlc-grpc/config"
	"github.com/walterwanderley/sqlc-grpc/converter"
)

func (pkg *Package) GlobalMod(modCfg config.ModConfig, roles []string) {
	pkgServices := make([]*Service, 0)
	for _, s := range modCfg.AddServices {
		if s.Method == "" {
			s.Method = "GET"
		}
		var reqFields []*Field
		var resFields []*Field
		for _, reqField := range s.ReqFields {
			reqFields = append(reqFields, &Field{
				Name: reqField.Name,
				Type: reqField.Type,
			})
		}
		for _, resField := range s.ResFields {
			resFields = append(resFields, &Field{
				Name: resField.Name,
				Type: resField.Type,
			})
		}
		pkg.Messages[s.Name+"Params"] = &Message{
			Name:   s.Name + "Params",
			Fields: reqFields,
		}
		pkg.Messages[s.Name+"Response"] = &Message{
			Name:   s.Name + "Response",
			Fields: resFields,
		}
		pkgServices = append(pkgServices, &Service{
			Name:    s.Name,
			IsBlank: true,
			HttpSpecs: []HttpSpec{
				{
					Method: s.Method,
					Path:   s.Path,
				},
			},
		})
	}
	pkg.FilterServices(modCfg.RemoveServices)
	pkg.Services = append(pkgServices, pkg.Services...)
	for _, msg := range pkg.Messages {
		msgName := msg.Name
		if strings.HasSuffix(msg.Name, "Params") {
			msgName = msg.Name[0:len(msg.Name)-6] + "Request"
		}
		_fields := make([]*Field, 0)
		for _, field := range msg.Fields {
			var _ignoreField *Field
			for _, ignore := range modCfg.RemoveFields {
				if matched, err := path.Match(ignore, msgName+"."+converter.ToSnakeCase(field.Name)); err == nil && matched {
					_ignoreField = field
					break
				}
			}
			if _ignoreField == nil {
				_fields = append(_fields, field)
			}
		}
		msg.Fields = _fields
	}
	for name, moqPkg := range modCfg.Packages {
		if name == pkg.Package {
			pkg.GlobalMod(moqPkg, roles)
		}
	}
	for role, rolePkg := range modCfg.RolesFilter {
		if slices.Contains(roles, role) {
			pkg.GlobalMod(rolePkg, roles)
		}
	}
}

func (pkg *Package) ProtoMod(modCfg config.ModConfig, roles []string) {
	pkg.FilterServices(modCfg.IgnoreServices)
	for _, s := range modCfg.AddFields {
		var msg *Message
		msgName := s.Msg
		if strings.HasSuffix(s.Msg, "Request") {
			msgName = s.Msg[0:len(s.Msg)-7] + "Params"
		}
		for _, m := range pkg.Messages {
			if msgName == m.Name {
				msg = m
				break
			}
		}
		_Fields := make([]*Field, 0)
		if msg != nil {
			_Fields = append(_Fields, msg.Fields...)
		}
		for _, field := range s.Fields {
			_Fields = append(_Fields, &Field{
				Name: field.Name,
				Type: field.Type,
			})
		}
		pkg.Messages[msgName] = &Message{
			Name:   msgName,
			Fields: _Fields,
		}
	}
	for name, moqPkg := range modCfg.Packages {
		if name == pkg.Package {
			pkg.ProtoMod(moqPkg, roles)
		}
	}
	for role, rolePkg := range modCfg.RolesFilter {
		if slices.Contains(roles, role) {
			pkg.ProtoMod(rolePkg, roles)
		}
	}
}

func (p *Package) FilterServices(services []string) {
	_services := make([]*Service, 0)
	ignoredMessages := []string{}
	for _, pkg := range p.Services {
		ignore := false
		for _, service := range services {
			if matched, err := path.Match(service, pkg.Name); err == nil && matched {
				ignore = true
				break
			}
		}
		if !ignore {
			_services = append(_services, pkg)
		} else {
			ignoredMessages = append(ignoredMessages, pkg.Name+"Params", pkg.Name+"Response")
		}
	}
	_messages := make(map[string]*Message)
	for k, v := range p.Messages {
		if !slices.Contains(ignoredMessages, k) {
			_messages[k] = v
		}
	}
	p.Services = _services
	p.Messages = _messages
}

func (p *Package) ModServices(modCfg config.ModConfig) {
	customServices := []string{}
	fset := token.NewFileSet()
	pkgs, err := parser.ParseFile(fset, filepath.Join(p.SrcPath, "service.go"), nil, parser.ParseComments)
	if err != nil {
		log.Println(err.Error())
		return
	}
	for _, decl := range pkgs.Decls {
		if fn, ok := decl.(*ast.FuncDecl); ok {
			if strings.TrimSpace(fn.Doc.Text()) != "auto generated by sqlc-grpc" {
				var buf bytes.Buffer
				err := printer.Fprint(&buf, fset, fn)
				if err != nil {
					log.Fatal(err)
				}
				p.CustomServiceComments = append(p.CustomServiceComments, strings.TrimSpace(fn.Doc.Text()))
				p.CustomServiceFunctions = append(p.CustomServiceFunctions, buf.String())
				for _, pkg := range p.Services {
					if pkg.Name == fn.Name.Name {
						customServices = append(customServices, pkg.Name)
					}
				}
			} else if slices.Contains(modCfg.IgnoreServices, fn.Name.Name) {
				fn.Doc = nil
				var buf bytes.Buffer
				err := printer.Fprint(&buf, fset, fn)
				if err != nil {
					log.Fatal(err)
				}
				p.CustomServiceComments = append(p.CustomServiceComments, "")
				p.CustomServiceFunctions = append(p.CustomServiceFunctions, buf.String())
			}
		}
	}
	_services := make([]*Service, 0)
	for _, pkg := range p.Services {
		if !slices.Contains(customServices, pkg.Name) && !slices.Contains(modCfg.IgnoreServices, pkg.Name) {
			pkg.Comments = []string{"auto generated by sqlc-grpc"}
			_services = append(_services, pkg)
		}
	}
	p.Services = _services
}
