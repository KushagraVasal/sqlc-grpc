// Code generated by sqlc-grpc (https://github.com/walterwanderley/sqlc-grpc).

package main

import (
	"context"
	"database/sql"
	_ "embed"
	"log/slog"
	"os"

	"github.com/XSAM/otelsql"
	semconv "go.opentelemetry.io/otel/semconv/v1.23.0"
	{{if eq .SqlPackage "pgx/v5"}}"github.com/jackc/pgx/v5/pgxpool"{{else}}_ "{{ .DatabaseImport}}"{{end}}
	"github.com/minio/minio-go/v7"
	"github.com/minio/minio-go/v7/pkg/credentials"
	"github.com/nats-io/nats.go"
	"github.com/nats-io/nats.go/jetstream"
	"github.com/typesense/typesense-go/v3/typesense"

	"{{ .GoModule}}/internal/server"
	"{{ .GoModule}}/internal/server/instrumentation/trace"
)

func ParseEnv() {
	// Database
	dbURL = "postgres://"
	if os.Getenv("POSTGRES_USER") != "" {
		dbURL += os.Getenv("POSTGRES_USER")
	} else {
		dbURL += "postgres"
	}
	dbURL += ":"
	if os.Getenv("POSTGRES_PASSWORD") != "" {
		dbURL += os.Getenv("POSTGRES_PASSWORD")
	} else {
		dbURL += "postgres"
	}
	dbURL += "@"
	if os.Getenv("POSTGRES_HOST") != "" {
		dbURL += os.Getenv("POSTGRES_HOST") + ":" + os.Getenv("POSTGRES_PORT")
	} else {
		dbURL += "localhost:5432"
	}
	dbURL += "/" + os.Getenv("POSTGRES_DB")
	if os.Getenv("POSTGRES_SSL_MODE") != "" {
		dbURL += "?sslmode=" + os.Getenv("POSTGRES_SSL_MODE")
	}
    {{if .TypeSense}}
	// Typesense
	tsUrl = os.Getenv("TYPESENSE_URL")
	tsKey = os.Getenv("TYPESENSE_API_KEY")
	{{end}}
    {{if .S3}}
	// S3
	s3Url = os.Getenv("S3_URL")
	s3AccessKey = os.Getenv("S3_ACCESS_KEY")
	s3SecretKey = os.Getenv("S3_SECRET_KEY")
	s3SSL = os.Getenv("S3_SSL") == "true"
	{{end}}
    {{if .Nats}}
	// NATS
	natsUrl = os.Getenv("NATS_URL")
	{{end}}
}

func DbInit(cfg server.Config, dbURL string) ({{if eq .SqlPackage "pgx/v5"}}*pgxpool.Pool{{else}}*sql.DB{{end}}, error) {
    {{if .DistributedTracing}}var db {{if eq .SqlPackage "pgx/v5"}}*pgxpool.Pool{{else}}*sql.DB{{end}}
	if cfg.TracingEnabled() {
		flush, err := trace.Init(context.Background(), serviceName, cfg.OtlpEndpoint)
		if err != nil {
			return nil, err
		}
		defer flush()
		{{if eq .SqlPackage "pgx/v5"}}
		dbCfg, err := pgxpool.ParseConfig(dbURL)
		if err != nil {
    		return nil, err
		}
		dbCfg.ConnConfig.Tracer = otelpgx.NewTracer()
		db, err = pgxpool.NewWithConfig(context.Background(), dbCfg)
		if err != nil {
    		return nil, err
		}
		{{else}}
		db, err = otelsql.Open("{{ .DatabaseDriver}}", dbURL, otelsql.WithAttributes(
			{{if eq .Database "mysql"}}semconv.DBSystemMySQL{{else if eq .Database "sqlite"}}semconv.DBSystemSqlite{{else}}semconv.DBSystemPostgreSQL{{end}},
		))
		if err != nil {			
			return nil, err
		}

		err = otelsql.RegisterDBStatsMetrics(db, otelsql.WithAttributes(
			{{if eq .Database "mysql"}}semconv.DBSystemMySQL{{else if eq .Database "sqlite"}}semconv.DBSystemSqlite{{else}}semconv.DBSystemPostgreSQL{{end}},
		))
		if err != nil {
			return nil, err
		}{{end}}
	} else {
        var err error
	    {{if eq .SqlPackage "pgx/v5"}}db, err = pgxpool.New(context.Background(), dbURL)
		{{else}}	
		db, err = sql.Open("{{if eq .Database "mysql"}}mysql{{else if eq .Database "sqlite"}}sqlite3{{else}}pgx{{end}}", dbURL)
		{{end}}if err != nil {
			return nil, err
		}
	}
	defer db.Close()
	{{else}}
	{{if eq .SqlPackage "pgx/v5"}}
		db, err := pgxpool.New(context.Background(), dbURL)
	{{else}}
	db, err := sql.Open("{{ .DatabaseDriver}}", dbURL)
	{{end}}if err != nil {
		return nil, err
	}
	defer db.Close()
	{{end}}
	{{if .Litestream}}if replicationURL != "" {
		slog.Info("litestream replication", "url", replicationURL)
		lsdb, err := litestream.Replicate(context.Background(), dbURL, replicationURL)
		if err != nil { return nil, fmt.Errorf("init replication error: %w", err) }
		defer lsdb.Close()
	}
	{{end -}}
	{{if .MigrationPath}}{{if eq .SqlPackage "pgx/v5"}}
	dbMigration, err := sql.Open("pgx", dbURL)
	if err != nil {
		return nil, err
	}
	err = ensureSchema(dbMigration)
	if err != nil { slog.Error("migration error", "error", err) }
	dbMigration.Close()
	{{else}}
	if err := ensureSchema(db); err != nil { slog.Error("migration error", "error", err) }{{end}}{{end}}
	return db, nil
}

{{if .TypeSense}}
func TsInit(tsUrl string, tsKey string) *typesense.Client {
	return typesense.NewClient(
		typesense.WithServer(tsUrl),
		typesense.WithAPIKey(tsKey),
	)
}
{{end}}

{{if .S3}}
func S3Init(s3Url string, s3AccessKey string, s3SecretKey string, s3IsSSL bool) (*minio.Client, error) {
	return minio.New(s3Url, &minio.Options{
		Creds:  credentials.NewStaticV4(s3AccessKey, s3SecretKey, ""),
		Secure: s3IsSSL,
	})
}
{{end}}

{{if .Nats}}
func NatsInit(natsUrl string) (*jetstream.JetStream, error) {
	conn, err := nats.Connect(natsUrl)
	if err != nil {
		return nil, err
	}
	js, err := jetstream.New(conn)
	if err != nil {
		return nil, err
	}
	return &js, nil
}
{{end}}